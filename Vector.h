#ifndef VECTOR_H_#define VECTOR_H_/// @cond
#include <stdint.h>/// @endcond
#include "General.h"#include "Error.h"template<class tPlacedVector>void * operator new(size_t s, tPlacedVector &Vector) {  AVP_ASSERT(s == sizeof(Vector.Data[0]));  AVP_ASSERT(Vector.Nfilled < N_ELEMENTS(Vector.Data));  return (void *)&Vector.Data[Vector.Nfilled++];} // placement newnamespace avp {  template<typename T, size_t Length>  class Vector {      // index checking vector    protected:      T Data[Length];    public:      Vector() {}      Vector(const T &rhs) { *this = rhs; }      Vector(const Vector<T,Length> &rhs) { *this = rhs; }#define SELF_OP_V(Class,...) \      template<typename T1 = T> \      const Class &operator __VA_ARGS__##=(const Class<T1,Length> &rhs) { \        for(size_t i=0; i < Length; i++) Vector<T,Length>::Data[i] __VA_ARGS__##= rhs[i]; return *this; }      SELF_OP_V(Vector) // assignment operator#define SELF_OP_T(Class,...) \      template<typename T1 = T> \      const Class &operator __VA_ARGS__##=(const T1 &rhs) { \        for(size_t i=0; i < Length; i++) Vector<T,Length>::Data[i] __VA_ARGS__##= rhs; return *this; }      SELF_OP_T(Vector) // assign a single value T to the whole vector      // const Vector &operator=(const T *p) { for(size_t i=0; i < Length; i++) Data[i] = p[i];  return *this;}      T &operator[](uint8_t i) { AVP_ASSERT(i < Length); return Data[i]; }      const T &operator[](uint8_t i) const { AVP_ASSERT(i < Length); return Data[i];}      constexpr size_t N() const { return Length; }      const T* get_ptr() const { return Data; }      const T* after_last() const { return Data + Length; }      inline friend bool operator!=(Vector const &v1, Vector const &v2) {        if(&v1 == &v2) return false;        for(size_t i=0; i < Length; ++i) if(v1.Data[i] != v2.Data[i]) return true;        return false;      } // operator!=      inline friend bool operator==(Vector const &v1, Vector const &v2) { return !(v1 != v2); }      // SELF_OP_V(Vector) // this is default operation=      template<size_t from, size_t to = Length-1>      Vector<T,to-from+1> Sub() const { Vector<T,to-from+1> t; for(size_t i = from; i <= to; i++) t[i-from] = Data[i]; return t; }  }; // class Vector  template<typename T, size_t Length>  class PlacedVector: public Vector<T,Length> {    protected:      size_t Nfilled;    public:      PlacedVector():Nfilled(0) {}      friend void * ::operator new<PlacedVector>(size_t, PlacedVector &);  }; // PlacedVector  template<typename T, size_t Length>  class ArithVector: public Vector<T,Length> {    public:      ArithVector() {}      ArithVector(const T &rhs):Vector<T,Length>(rhs) {}      ArithVector(Vector<T,Length> t):Vector<T,Length>(t) {}      // SELF_OP_T(ArithVector) // it is  inherited      SELF_OP_T(ArithVector,+)      SELF_OP_T(ArithVector,-)      SELF_OP_T(ArithVector,*)      SELF_OP_T(ArithVector,/)      // SELF_OP_V(ArithVector) // it is  inherited      SELF_OP_V(ArithVector,+)      SELF_OP_V(ArithVector,-)      SELF_OP_V(ArithVector,*)      SELF_OP_V(ArithVector,/)// FOllowing are binary operators as friends#define BINARY_OP_FROM_SELF(op) \inline friend ArithVector operator op (ArithVector x1, const ArithVector &x2) { return x1 op##= x2; } \template <typename X> \inline friend ArithVector operator op (ArithVector x1, X x2) { return x1 op##= x2; }      BINARY_OP_FROM_SELF(-)      BINARY_OP_FROM_SELF(+)      BINARY_OP_FROM_SELF(*)      BINARY_OP_FROM_SELF(/)#undef BINARY_OP_FROM_SELF//      template<size_t from, size_t to = Length-1>//      ArithVector<T,to-from+1> Sub() { ArithVector<T,to-from+1> t; for(size_t i = from; i <= to; i++) t[i-from] = Data[i]; return t; }  }; // class ArithVector} // namespace avp#endif /* VECTOR_H_ */