/* * Complex.h * * Created: 11/12/2013 1:29:20 PM *  Author: panasyuk */#ifndef AVP_COMPLEX_H_#define AVP_COMPLEX_H_// #include <math.h>namespace avp {  template<typename T = float>  struct Complex {    T Real; T Imag;    Complex() {}    Complex(T const &Real_, T const &Imag_ = 0): Real(Real_), Imag(Imag_) {}    template<typename T1 = T>    Complex(const Complex<T1> &a): Real(a.Real), Imag(a.Imag) {}    template <typename X>    const Complex &operator= (const Complex<X> &a) {      Real = a.Real;      Imag = a.Imag;      return *this;    }    Complex conj() const { return Complex(Real, -Imag); }    T abs_sqr() const { return Real*Real + Imag*Imag; }    Complex inverse() const { return Complex(Real,-Imag)/abs_sqr(); }    template <typename X>    const Complex &operator+= (const Complex<X> &a2) {      Real += a2.Real;      Imag += a2.Imag;      return *this;    }    template <typename T1>    const Complex &operator+= (T1 a2) {      Real += a2;      return *this;    }   inline friend Complex operator + (T x1, const Complex &x2) { return x2 + x1; }    template <typename X>    const Complex &operator-= (const Complex<X> &a2) {      Real -= a2.Real;      Imag -= a2.Imag;      return *this;    }    template <typename T1>    const Complex &operator-= (T1 a2) {      Real -= a2;      return *this;    }    inline friend Complex operator - (T x1, const Complex &x2) { return Complex(x1 - x2.Real, -x2.Imag); }    template <typename X>    const Complex &operator*= (const Complex<X> &a) {      Real = Real*a.Real - Imag*a.Imag; Imag = Real*a.Imag + Imag*a.Real;      return *this;    } // *=    template <typename T1>    const Complex &operator*= (T1 a) {      Real *= a; Imag *= a;      return *this;    } // *=    inline friend Complex operator * (T x1, Complex x2) { return x2 *= x1; }    template <typename X>    const Complex &operator/= (const Complex<X> &a) { // we can not use binary /, or we get into infinite recursion      return *this *= a.inverse();    }    template <typename T1>    const Complex &operator/= (T1 a) { // we can not use binary /, or we get into infinite recursion      Real /= a; Imag /= a;      return *this;    } // /=    inline friend Complex operator / (T x1, const Complex &x2) { return x2.inverse()*x1; }    static Complex conj(Complex a) { return a.conj(); }  // conj// FOllowing are binary operators as friends#define BINARY_OP_FROM_SELF(op) \template <typename X> \inline friend Complex operator op (Complex x1, const Complex<X> &x2) { return x1 op##= x2; } \template <typename X> \inline friend Complex operator op (Complex x1, X x2) { return x1 op##= x2; }    BINARY_OP_FROM_SELF(-)    BINARY_OP_FROM_SELF(+)    BINARY_OP_FROM_SELF(*)    BINARY_OP_FROM_SELF(/)#undef BINARY_OP_FROM_SELF    inline friend bool operator==(Complex const &v1, Complex const &v2) { return v1.Real == v2.Real && v1.Imag == v2.Imag; }    inline friend bool operator!=(Complex const &v1, Complex const &v2) { return !(v1 == v2); }    bool IsFinite() { return isfinite(Real) && isfinite(Imag); }    bool IsNormal() { return isnormal(Real) && isnormal(Imag); }    // isnormal and isfinite are defined as macro, so no overloading  }; // Complex} // namespace avp#endif /* AVP_COMPLEX_H_ */